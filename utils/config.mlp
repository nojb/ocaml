#2 "utils/config.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* The main OCaml version string has moved to ../VERSION *)
let version = Sys.ocaml_version

let ini_name = "ocaml.ini"

let () =
  let exe_dir = Filename.dirname Sys.executable_name in
  let lib_dir =
    Filename.concat (Filename.concat exe_dir Filename.parent_dir_name)
      (Filename.concat "lib" "ocaml") in
  let search_path = [exe_dir;lib_dir] in
  let files = List.map (fun s -> Filename.concat s ini_name) search_path in
  match List.find_opt Sys.file_exists files with
  | Some filename -> Readconfig.read_config_file filename
  | None ->
      (* [builtin_config] is a value of type [string] containing a hard-coded
         copy of the generated config file. Its definition is inserted at the
         top of the file by the build system. *)
      Readconfig.read_config_string builtin_config

let get key =
  match Readconfig.key_val key with
  | Some v -> v
  | None -> Printf.eprintf "Configuration option `%s' is not set\n" key; exit 2

let bad_config key vl =
  Printf.eprintf "Invalid value `%s' for configuration option `%s'\n"
    (String.concat " " vl) key;
  exit 2

let get_string key =
  match get key with
  | [v] -> v
  | vl -> bad_config key vl

let get_bool key =
  match get_string key with
  | "true" -> true
  | "false" -> false
  | v -> bad_config key [v]

let get_int key =
  let v = get_string key in
  match int_of_string_opt v with
  | Some n -> n
  | None -> bad_config key [v]

let standard_library_default = get_string "libdir"

let standard_library =
  try
    Sys.getenv "OCAMLLIB"
  with Not_found ->
  try
    Sys.getenv "CAMLLIB"
  with Not_found ->
    standard_library_default

let ccomp_type = get_string "ccomptype"
let c_compiler = get_string "cc"
let c_output_obj = get_string "outputobj"
let c_has_debug_prefix_map = get_bool "cc_has_debug_prefix_map"
let as_has_debug_prefix_map = get_bool "as_has_debug_prefix_map"
let ocamlc_cflags = get_string "ocamlc_cflags"
let ocamlc_cppflags = get_string "ocamlc_cppflags"
(* #7678: ocamlopt uses these only to compile .c files, and the behaviour for
          the two drivers should be identical. *)
let ocamlopt_cflags = get_string "ocamlc_cflags"
let ocamlopt_cppflags = get_string "ocamlopt_cppflags"
let bytecomp_c_libraries = get_string "bytecclibs"
(* bytecomp_c_compiler and native_c_compiler have been supported for a
   long time and are retained for backwards compatibility.
   For programs that don't need compatibility with older OCaml releases
   the recommended approach is to use the constituent variables
   c_compiler, ocamlc_cflags, ocamlc_cppflags etc., directly.
*)
let bytecomp_c_compiler =
  c_compiler ^ " " ^ ocamlc_cflags ^ " " ^ ocamlc_cppflags
let native_c_compiler =
  c_compiler ^ " " ^ ocamlopt_cflags ^ " " ^ ocamlopt_cppflags
let native_c_libraries = get_string "nativecclibs"
let native_pack_linker = get_string "packld"
let ranlib = get_string "ranlibcmd"
let ar = get_string "arcmd"
let flexlink_flags = get_string "flexlink_flags"
let flexlink_ldflags = get_string "flexlink_ldflags"
let mkdll = get_string "mkdll"
let mkexe = get_string "mkexe"
let mkmaindll = get_string "mkmaindll"
let mkdll, mkexe, mkmaindll =
  (* @@DRA Cygwin - but only if shared libraries are enabled, which we
     should be able to detect? *)
  if Sys.os_type = "Win32" then
    try
      let flexlink =
        let flexlink = Sys.getenv "OCAML_FLEXLINK" in
        let f i =
          let c = flexlink.[i] in
          if c = '/' then '\\' else c in
        (String.init (String.length flexlink) f) ^ " " ^ flexlink_flags in
      flexlink,
      flexlink ^ " -exe" ^ flexlink_ldflags,
      flexlink ^ " -maindll"
    with Not_found ->
      mkdll, mkexe, mkmaindll
  else
    mkdll, mkexe, mkmaindll

let flambda = get_bool "flambda"
let with_flambda_invariants = get_bool "with_flambda_invariants"
let safe_string = get_bool "force_safe_string"
let default_safe_string = get_bool "default_safe_string"
let windows_unicode = get_int "windows_unicode" != 0
let supports_shared_libraries = get_bool "supports_shared_libraries"

let flat_float_array = get_bool "flat_float_array"

let function_sections = get_bool "function_sections"
let afl_instrument = get_bool "afl_instrument"

let exec_magic_number = "Caml1999X027"
    (* exec_magic_number is duplicated in runtime/caml/exec.h *)
and cmi_magic_number = "Caml1999I027"
and cmo_magic_number = "Caml1999O027"
and cma_magic_number = "Caml1999A027"
and cmx_magic_number =
  if flambda then
    "Caml1999y027"
  else
    "Caml1999Y027"
and cmxa_magic_number =
  if flambda then
    "Caml1999z027"
  else
    "Caml1999Z027"
and ast_impl_magic_number = "Caml1999M027"
and ast_intf_magic_number = "Caml1999N027"
and cmxs_magic_number = "Caml1999D027"
and cmt_magic_number = "Caml1999T027"

let interface_suffix = ref ".mli"

let max_tag = 245
(* This is normally the same as in obj.ml, but we have to define it
   separately because it can differ when we're in the middle of a
   bootstrapping phase. *)
let lazy_tag = 246

let max_young_wosize = 256
let stack_threshold = 256 (* see runtime/caml/config.h *)
let stack_safety_margin = 60

let architecture = get_string "arch"
let model = get_string "model"
let system = get_string "system"

let asm = get_string "asm"
let asm_cfi_supported = get_bool "asm_cfi_supported"
let with_frame_pointers = get_bool "with_frame_pointers"
let spacetime = get_bool "with_spacetime"
let enable_call_counts = get_bool "enable_call_counts"
let libunwind_available = get_bool "libunwind_available"
let libunwind_link_flags = get_string "libunwind_link_flags"
let profinfo = get_bool "with_profinfo"
let profinfo_width = get_int "profinfo_width"

let ext_exe = get_string "exe"
let ext_obj = get_string "ext_obj"
let ext_asm = get_string "ext_asm"
let ext_lib = get_string "ext_lib"
let ext_dll = get_string "ext_dll"

let host = get_string "host"
let target = get_string "target"

let default_executable_name =
  match Sys.os_type with
    "Unix" -> "a.out"
  | "Win32" | "Cygwin" -> "camlprog.exe"
  | _ -> "camlprog"

let systhread_supported = get_bool "systhread_support";;

let flexdll_dirs =
  let s = get_string "flexdll_dir" in
  if s = "" then [] else [s]
;;

type configuration_value =
  | String of string
  | Int of int
  | Bool of bool

let configuration_variables =
  let p x v = (x, String v) in
  let p_int x v = (x, Int v) in
  let p_bool x v = (x, Bool v) in
[
  p "version" version;
  p "standard_library_default" standard_library_default;
  p "standard_library" standard_library;
  p "ccomp_type" ccomp_type;
  p "c_compiler" c_compiler;
  p "ocamlc_cflags" ocamlc_cflags;
  p "ocamlc_cppflags" ocamlc_cppflags;
  p "ocamlopt_cflags" ocamlopt_cflags;
  p "ocamlopt_cppflags" ocamlopt_cppflags;
  p "bytecomp_c_compiler" bytecomp_c_compiler;
  p "native_c_compiler" native_c_compiler;
  p "bytecomp_c_libraries" bytecomp_c_libraries;
  p "native_c_libraries" native_c_libraries;
  p "native_pack_linker" native_pack_linker;
  p "ranlib" ranlib;
  p "architecture" architecture;
  p "model" model;
  p_int "int_size" Sys.int_size;
  p_int "word_size" Sys.word_size;
  p "system" system;
  p "asm" asm;
  p_bool "asm_cfi_supported" asm_cfi_supported;
  p_bool "with_frame_pointers" with_frame_pointers;
  p "ext_exe" ext_exe;
  p "ext_obj" ext_obj;
  p "ext_asm" ext_asm;
  p "ext_lib" ext_lib;
  p "ext_dll" ext_dll;
  p "os_type" Sys.os_type;
  p "default_executable_name" default_executable_name;
  p_bool "systhread_supported" systhread_supported;
  p "host" host;
  p "target" target;
  p_bool "flambda" flambda;
  p_bool "spacetime" spacetime;
  p_bool "safe_string" safe_string;
  p_bool "default_safe_string" default_safe_string;
  p_bool "flat_float_array" flat_float_array;
  p_bool "function_sections" function_sections;
  p_bool "afl_instrument" afl_instrument;
  p_bool "windows_unicode" windows_unicode;
  p_bool "supports_shared_libraries" supports_shared_libraries;

  p "exec_magic_number" exec_magic_number;
  p "cmi_magic_number" cmi_magic_number;
  p "cmo_magic_number" cmo_magic_number;
  p "cma_magic_number" cma_magic_number;
  p "cmx_magic_number" cmx_magic_number;
  p "cmxa_magic_number" cmxa_magic_number;
  p "ast_impl_magic_number" ast_impl_magic_number;
  p "ast_intf_magic_number" ast_intf_magic_number;
  p "cmxs_magic_number" cmxs_magic_number;
  p "cmt_magic_number" cmt_magic_number;
]

let print_config_value oc = function
  | String s ->
      Printf.fprintf oc "%s" s
  | Int n ->
      Printf.fprintf oc "%d" n
  | Bool p ->
      Printf.fprintf oc "%B" p

let print_config oc =
  let print (x, v) =
    Printf.fprintf oc "%s: %a\n" x print_config_value v in
  List.iter print configuration_variables;
  flush oc;
;;

let config_var x =
  match List.assoc_opt x configuration_variables with
  | None -> None
  | Some v ->
      let s = match v with
        | String s -> s
        | Int n -> Int.to_string n
        | Bool b -> string_of_bool b
      in
      Some s
